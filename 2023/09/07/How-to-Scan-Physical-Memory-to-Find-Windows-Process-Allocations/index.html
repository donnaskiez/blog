<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="IntroductionMemory scanning is a very common forensics tool used by anti cheats, security experts and any other parties looking to analyse what is or has been running on a system. Here, we will be us">
<meta property="og:type" content="article">
<meta property="og:title" content="How to Scan Physical Memory to Find Windows Process Allocations">
<meta property="og:url" content="https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/index.html">
<meta property="og:site_name" content="donnaskiez.dev">
<meta property="og:description" content="IntroductionMemory scanning is a very common forensics tool used by anti cheats, security experts and any other parties looking to analyse what is or has been running on a system. Here, we will be us">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/intelpaging.png">
<meta property="og:image" content="https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/intelimage2.png">
<meta property="article:published_time" content="2023-09-07T10:16:51.000Z">
<meta property="article:modified_time" content="2023-09-20T03:48:09.940Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Windows Internals">
<meta property="article:tag" content="Anti-Cheat">
<meta property="article:tag" content="Kernel Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/intelpaging.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>How to Scan Physical Memory to Find Windows Process Allocations</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/projects/">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/06/12/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&text=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&is_video=false&description=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=How to Scan Physical Memory to Find Windows Process Allocations&body=Check out this article: https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&name=How to Scan Physical Memory to Find Windows Process Allocations&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&t=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executive-Object-Header-Structure"><span class="toc-number">2.</span> <span class="toc-text">Executive Object Header Structure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-Header-Structure"><span class="toc-number">2.1.</span> <span class="toc-text">Object Header Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional-Headers"><span class="toc-number">2.2.</span> <span class="toc-text">Optional Headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Header-Structure"><span class="toc-number">2.3.</span> <span class="toc-text">Header Structure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-Pool-Allocations"><span class="toc-number">3.</span> <span class="toc-text">Windows Pool Allocations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pool-Header-Structure"><span class="toc-number">3.1.</span> <span class="toc-text">Pool Header Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocation-Pool-Tags"><span class="toc-number">3.2.</span> <span class="toc-text">Allocation Pool Tags</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#An-Introduction-to-Memory-Paging"><span class="toc-number">4.</span> <span class="toc-text">An Introduction to Memory Paging</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intel-Paging-Structure"><span class="toc-number">4.1.</span> <span class="toc-text">Intel Paging Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-Address-structure"><span class="toc-number">4.2.</span> <span class="toc-text">Virtual Address structure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Table-Walking-on-Modern-Windows"><span class="toc-number">5.</span> <span class="toc-text">Page Table Walking on Modern Windows</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Pages"><span class="toc-number">5.1.</span> <span class="toc-text">Large Pages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Physical-Memory-Ranges"><span class="toc-number">5.2.</span> <span class="toc-text">Physical Memory Ranges</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanning-a-Page-For-Process-Allocations"><span class="toc-number">6.</span> <span class="toc-text">Scanning a Page For Process Allocations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-a-Process-Signature"><span class="toc-number">7.</span> <span class="toc-text">Building a Process Signature</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Finding-the-Robust-Fields"><span class="toc-number">7.1.</span> <span class="toc-text">Finding the Robust Fields</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Building-our-signature"><span class="toc-number">7.2.</span> <span class="toc-text">Building our signature</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Results"><span class="toc-number">8.</span> <span class="toc-text">Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">9.</span> <span class="toc-text">Conclusion</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        How to Scan Physical Memory to Find Windows Process Allocations
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">donna</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-09-07T10:16:51.000Z" class="dt-published" itemprop="datePublished">2023-09-07</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Anti-Cheat/" rel="tag">Anti-Cheat</a>, <a class="p-category" href="/tags/Kernel-Programming/" rel="tag">Kernel Programming</a>, <a class="p-category" href="/tags/Windows-Internals/" rel="tag">Windows Internals</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <!-- TOC --><a name="introduction"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Memory scanning is a very common forensics tool used by anti cheats, security experts and any other parties looking to analyse what is or has been running on a system. Here, we will be using memory scanning as a method to find processes that have been unliked from the <code>PsActiveProcessList</code>, which is a linked list containing all running processes on a Windows system. It is common for malware, rootkits and game cheats to unlink themselves or a target process from this list, so being able to detect these unlinked processes is an extremely valuable skill for any defensive security engineer. In this post, we will explore how we can do just that by scanning the physical memory on a Windows machine and performing a simple pattern scan. We will then explore how we can harden our process structure signature to ensure it works across both major and minor versions of Windows as well as minimising the chances of false positives occuring. Lets get into it.</p>
<p>Lets first start by exploring what a process allocation looks like on windows, starting with the object headers.</p>
<!-- TOC --><a name="executive-object-header-structure"></a>
<h2 id="Executive-Object-Header-Structure"><a href="#Executive-Object-Header-Structure" class="headerlink" title="Executive Object Header Structure"></a>Executive Object Header Structure</h2><p>Objects in windows are managed by whats called the Windows Object Manager. It is responsible for keeping track of resources allocated by a process. Some of these objects include processes, threads, directories, files, jobs etc. When an object is allocated, the object manager will determine what object headers are required by the object being allocated and reserve space for these headers. These headers vary in size aswell as whether or not the header is required or optional.</p>
<!-- TOC --><a name="object-header-structure"></a>
<h3 id="Object-Header-Structure"><a href="#Object-Header-Structure" class="headerlink" title="Object Header Structure"></a>Object Header Structure</h3><p>The only required object header is defined as the <code>OBJECT_HEADER</code>. While the objects themselves differ, every object has the same <code>OBJECT_HEADER</code> which sits right above the objects base address. This allows the windows subsystem object manager to easily keep track of objects. The object header is defined as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt nt!_OBJECT_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PointerCount     : Int8B</span><br><span class="line">   +<span class="number">0x008</span> HandleCount      : Int8B</span><br><span class="line">   +<span class="number">0x008</span> NextToFree       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x018</span> TypeIndex        : UChar</span><br><span class="line">   +<span class="number">0x019</span> TraceFlags       : UChar</span><br><span class="line">   +<span class="number">0x019</span> DbgRefTrace      : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x019</span> DbgTracePermanent : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01a</span> InfoMask         : UChar</span><br><span class="line">   +<span class="number">0x01b</span> Flags            : UChar</span><br><span class="line">   +<span class="number">0x01b</span> NewObject        : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01b</span> KernelObject     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01b</span> KernelOnlyAccess : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01b</span> ExclusiveObject  : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01b</span> PermanentObject  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01b</span> DefaultSecurityQuota : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01b</span> SingleHandleEntry : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01b</span> DeletedInline    : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x01c</span> Reserved         : Uint4B</span><br><span class="line">   +<span class="number">0x020</span> ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +<span class="number">0x020</span> QuotaBlockCharged : Ptr64 Void</span><br><span class="line">   +<span class="number">0x028</span> SecurityDescriptor : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> Body             : _QUAD</span><br></pre></td></tr></table></figure>

<p>The structure contains various fields to keep track of reference counts, object type and various other house keeping necessities. What’s important to us is the <code>InfoMask</code> field, which is a bitmask indicating which optional headers the object has in addition to the object header.</p>
<!-- TOC --><a name="optional-headers"></a>
<h3 id="Optional-Headers"><a href="#Optional-Headers" class="headerlink" title="Optional Headers"></a>Optional Headers</h3><p>Optional headers are headers that aren’t required for an object. The optional headers an object has can differ depending on the object type. There are a number of optional headers available, all of them listed blow, that correspond to a certain bit in the <code>InfoMask</code> field.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------+-----------------------------+-----------+</span><br><span class="line">| Bit        | Header Name                 | Size      |</span><br><span class="line">+------------+-----------------------------+-----------+</span><br><span class="line">| <span class="number">0x1</span>        | OBJECT_HEADER_CREATOR_INFO  | <span class="number">0x20</span>      |</span><br><span class="line">| <span class="number">0x2</span>        | OBJECT_HEADER_NAME_INFO     | <span class="number">0x20</span>      |</span><br><span class="line">| <span class="number">0x4</span>        | OBJECT_HEADER_HANDLE_INFO   | <span class="number">0x10</span>      |</span><br><span class="line">| <span class="number">0x8</span>        | OBJECT_HEADER_QUOTA_INFO    | <span class="number">0x20</span>      |</span><br><span class="line">| <span class="number">0x10</span>       | OBJECT_HEADER_PROCESS_INFO  | <span class="number">0x10</span>      |</span><br><span class="line">| <span class="number">0x20</span>       | OBJECT_HEADER_AUDIT_INFO    | <span class="number">0x10</span>      |</span><br><span class="line">| <span class="number">0x40</span>       | OBJECT_HEADER_EXTENDED_INFO | <span class="number">0x10</span>      |</span><br><span class="line">| <span class="number">0x80</span>       | OBJECT_HEADER_PADDING_INFO  | Unknown   |</span><br><span class="line">+------------+-----------------------------+-----------+</span><br></pre></td></tr></table></figure>

<p>While the contents of these headers is out of the scope of this article, whats important to note is that each optional header differs in size, and objects of the same type can have a varying number of optional headers.</p>
<!-- TOC --><a name="header-structure"></a>
<h3 id="Header-Structure"><a href="#Header-Structure" class="headerlink" title="Header Structure"></a>Header Structure</h3><p>Now, lets have a look at what the entire allocation structure looks like from above now that we know what headers an object allocation has. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+--------------------------------------------------------+</span><br><span class="line">| _POOL_HEADER              | Pool allocation information                            |</span><br><span class="line">+---------------------------+--------------------------------------------------------+</span><br><span class="line">| _OPTIONAL_HEADER ...      | Additional optional headers <span class="keyword">if</span> applicable.             |</span><br><span class="line">+---------------------------+--------------------------------------------------------+</span><br><span class="line">| _OPTIONAL_HEADER <span class="number">1</span>        | Optional header <span class="number">1</span>, <span class="keyword">if</span> applicable                       |</span><br><span class="line">+---------------------------+--------------------------------------------------------+</span><br><span class="line">| _OBJECT_HEADER            | Metadata about the object, including type and          |</span><br><span class="line">|                           | reference count.                                       |</span><br><span class="line">+---------------------------+--------------------------------------------------------+</span><br><span class="line">| _OBJECT (_EPROCESS etc.)  | Specific object <span class="title function_">type</span> <span class="params">(e.g., processes, threads, etc.)</span>  |</span><br><span class="line">|                           | containing data.                                       |</span><br><span class="line">+---------------------------+--------------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>What we can see from the above structure, is that the <code>POOL_HEADER</code> is the first structure, followed by any optional headers, then the <code>OBJECT_HEADER</code> and finally the object. This means that if we can figure out what optional headers a process allocation has, we can determine the offset from the <code>_POOL_HEADER</code> to the base of the process allocation.</p>
<!-- TOC --><a name="windows-pool-allocations"></a>
<h2 id="Windows-Pool-Allocations"><a href="#Windows-Pool-Allocations" class="headerlink" title="Windows Pool Allocations"></a>Windows Pool Allocations</h2><p>The windows allocator splits kernel allocations into two categories - those smaller then a <code>PAGE_SIZE</code> i.e <code>4096</code> bytes and those bigger then a page. It is important to note that for allocations less then a <code>PAGE_SIZE</code>, this includes the <code>POOL_HEADER</code> structure aswell as any header objects. Whereas big pool allocations are managed completely seperately and require no bookkeeping structures. The focus of this article will be on ‘regular’ allocations, i.e allocations less then a <code>PAGE_SIZE</code>.</p>
<!-- TOC --><a name="pool-header-structure"></a>
<h3 id="Pool-Header-Structure"><a href="#Pool-Header-Structure" class="headerlink" title="Pool Header Structure"></a>Pool Header Structure</h3><p>The <code>POOL_HEADER</code> structure takes the following form:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt nt!_POOL_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PreviousSize     : Pos <span class="number">0</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> PoolIndex        : Pos <span class="number">8</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x002</span> BlockSize        : Pos <span class="number">0</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x002</span> PoolType         : Pos <span class="number">8</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> Ulong1           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> PoolTag          : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ProcessBilled    : Ptr64 _EPROCESS</span><br><span class="line">   +<span class="number">0x008</span> AllocatorBackTraceIndex : Uint2B</span><br><span class="line">   +<span class="number">0x00a</span> PoolTagHash      : Uint2B</span><br></pre></td></tr></table></figure>

<p>You can note the standard allocator bookkeeping fields, but the fields that are important to us are the <code>BlockSize</code>, which tells us the size of a block on the system allowing us to calculate the allocation size, and the <code>PoolTag</code> which stores the tag the pool was allocated with.</p>
<!-- TOC --><a name="allocation-pool-tags"></a>
<h3 id="Allocation-Pool-Tags"><a href="#Allocation-Pool-Tags" class="headerlink" title="Allocation Pool Tags"></a>Allocation Pool Tags</h3><p>The <code>PoolTag</code> field is an extremely important field for us, if we take a look at the <code>ExAllocatePool2</code> function signature:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLSPEC_RESTRICT PVOID <span class="title function_">ExAllocatePool2</span><span class="params">(</span></span><br><span class="line"><span class="params">  POOL_FLAGS Flags,</span></span><br><span class="line"><span class="params">  SIZE_T     NumberOfBytes,</span></span><br><span class="line"><span class="params">  ULONG      Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>We see that we pass in a 4 byte long tag. This tag can be anything, but for executive object allocations on Windows they use a specific tag, two of the main tags we care about are the following:</p>
<hr>
<table>
<thead>
<tr>
<th>Object Type</th>
<th>Tag</th>
<th>Tag in bytes</th>
</tr>
</thead>
<tbody><tr>
<td>Process</td>
<td>Proc</td>
<td>“\x50\x72\x6f\x63”</td>
</tr>
<tr>
<td>Thread</td>
<td>Thrd</td>
<td>“\x54\x68\x72\x64”</td>
</tr>
<tr>
<td>Desktop</td>
<td>Desk</td>
<td>“\x44\x65\x73\x6B”</td>
</tr>
<tr>
<td>Window Station</td>
<td>Wind</td>
<td>“\x57\x69\x6E\x64”</td>
</tr>
<tr>
<td>Mutants</td>
<td>Mute</td>
<td>“\x4D\x75\x74\x65”</td>
</tr>
<tr>
<td>File Objects</td>
<td>File</td>
<td>“\x46\x69\x6C\x65”</td>
</tr>
<tr>
<td>Drivers</td>
<td>Driv</td>
<td>“\x44\x72\x69\x76”</td>
</tr>
<tr>
<td>Symbolic Links</td>
<td>Link</td>
<td>“\x4C\x69\x6E\x6B”</td>
</tr>
</tbody></table>
<hr>
<p>This means that for every process allocation, the <code>PoolTag</code> field will be equal to following bytes <code>\x50\x72\x6f\x63</code>. This means we can effectively perform a basic signature scan on the entirety of the kernel which will, at the minimum, net us every process allocation, including unallocated processes and even potentially allocations that were from a previous boot. Keep this in mind as we move foward throughout the article and if you want to do some further reading on pool tags, <a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/t5/ask-the-performance-team/an-introduction-to-pool-tags/ba-p/372983">here is a good article by Microsoft.</a>. </p>
<p>Now that we have a basic understanding of how we can locate process allocations, we need to figure out how we can scan through kernel memory and perform a classic signature scan. For this, we are going to need to understand how paging works and how we can walk page tables to scan each physical page for the signature. Before we begin, a shoutout to <em>33c0c3</em> for the structures which can be found <a target="_blank" rel="noopener" href="https://www.unknowncheats.me/forum/general-programming-and-reversing/523359-introduction-physical-memory.html">here.</a> I also would highly recommend reading their article if you don’t already have a solid grasp of the concept of paging as this article will not cover them in the same level of detail. It is an excellent introduction to the topic and I cannot recommend it enough.</p>
<!-- TOC --><a name="an-introduction-to-memory-paging"></a>
<h2 id="An-Introduction-to-Memory-Paging"><a href="#An-Introduction-to-Memory-Paging" class="headerlink" title="An Introduction to Memory Paging"></a>An Introduction to Memory Paging</h2><p>Paging is a memory management scheme which allows a process’ physical address space to be non-contiguous while the virtual address space still appearing to be contiguous. This has many benefits, and is the reason all modern operating systems use the paging model, with the main benefit being reduced memory fragmentation allowing the operating system to maximise the utilisation of available memory. </p>
<!-- TOC --><a name="intel-paging-structure"></a>
<h3 id="Intel-Paging-Structure"><a href="#Intel-Paging-Structure" class="headerlink" title="Intel Paging Structure"></a>Intel Paging Structure</h3><p>The focus of this article is on intel based windows systems, so we will be using the intel paging structure, which is defined as follows:</p>
<img src="/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/intelpaging.png" class="" title="intel paging">

<p>As we can see from the diagram above, intels paging structure uses 4 levels, meaning there are 4 page tables - each page table is equal to <code>4096</code> bytes and stores <code>512</code> addresses (<code>512 * 8 = 4096</code>) which gives a virtual address the ability to reference <code>512^4</code> pages. Each entry in a page contains the physical address of the base of the next table in the structure as well as important information such as whether or not the page its pointing to is present in memory, whether it points to a large page and so on. This information is described in the following diagram:</p>
<img src="/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/intelimage2.png" class="" title="intel page address structure">

<p> So for example, if we dereference a <code>PML4 entry</code> we get the base physical address of the <code>PDPT</code> table and so on. To get the base address of the <code>PML4</code> table, we need to use a subset of the <code>cr3</code> register. This register value can be broken down as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">DIRECTORY_TABLE_BASE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UINT64 Ignored0         : <span class="number">3</span>;    <span class="comment">/* 2:0   */</span></span><br><span class="line">        UINT64 PageWriteThrough : <span class="number">1</span>;    <span class="comment">/* 3     */</span></span><br><span class="line">        UINT64 PageCacheDisable : <span class="number">1</span>;    <span class="comment">/* 4     */</span></span><br><span class="line">        UINT64 _Ignored1        : <span class="number">7</span>;    <span class="comment">/* 11:5  */</span></span><br><span class="line">        UINT64 PhysicalAddress  : <span class="number">36</span>;   <span class="comment">/* 47:12 */</span></span><br><span class="line">        UINT64 _Reserved0       : <span class="number">16</span>;   <span class="comment">/* 63:48 */</span></span><br><span class="line">    &#125; Bits;</span><br><span class="line">    UINT64 BitAddress;</span><br><span class="line">&#125; CR3, *PCR3;</span><br></pre></td></tr></table></figure>

<p>We can see bits 12 through 47 contain the base address of the <code>PML4</code> table. From here we need to figure out which entry in the table contains the correct address to the next page in the structure, for this we need to use our virtual address.</p>
<!-- TOC --><a name="virtual-address-structure"></a>
<h3 id="Virtual-Address-structure"><a href="#Virtual-Address-structure" class="headerlink" title="Virtual Address structure"></a>Virtual Address structure</h3><p>A virtual address (also known as the <em>linear address</em>) can be broken down into the following components:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">VIRTUAL_MEMORY_ADDRESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        UINT64 PageIndex : <span class="number">12</span>;  <span class="comment">/* 0:11  */</span></span><br><span class="line">        UINT64 PtIndex   : <span class="number">9</span>;   <span class="comment">/* 12:20 */</span></span><br><span class="line">        UINT64 PdIndex   : <span class="number">9</span>;   <span class="comment">/* 21:29 */</span></span><br><span class="line">        UINT64 PdptIndex : <span class="number">9</span>;   <span class="comment">/* 30:38 */</span></span><br><span class="line">        UINT64 Pml4Index : <span class="number">9</span>;   <span class="comment">/* 39:47 */</span></span><br><span class="line">        UINT64 Unused    : <span class="number">16</span>;  <span class="comment">/* 48:63 */</span></span><br><span class="line">    &#125; Bits;</span><br><span class="line">    UINT64 BitAddress;</span><br><span class="line">&#125; VIRTUAL_ADDRESS, * PVIRTUAL_ADDRESS;</span><br></pre></td></tr></table></figure>

<p>The <code>PtIndex</code>, <code>PdIndex</code>, <code>PdptIndex</code> and <code>Pml4Index</code> are all offsets which correlate to the index into their respective table. It is important to note that we must multiply this value by the size of a pointer, in most cases this being 8 since each entry is 8 bytes in size. The <code>PageIndex</code> represents the offset of the final memory location from the base of the physical page, this does not need to be multiplied by 8 since this is not an array of pointers unlike the previous 4 stages, but simply a block of contiguous memory. </p>
<!-- TOC --><a name="page-table-walking-on-modern-windows"></a>
<h2 id="Page-Table-Walking-on-Modern-Windows"><a href="#Page-Table-Walking-on-Modern-Windows" class="headerlink" title="Page Table Walking on Modern Windows"></a>Page Table Walking on Modern Windows</h2><p>Now that we have covered the basics of paging, lets get back to our orignal goal: enumerate the kernels physical memory and perform a signature scan for the process allocation tag <code>Proc</code>. So lets start by retrieving the current processors <code>cr3</code> register:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read the cr3 register and store it in a CR3 structure */</span></span><br><span class="line">cr3.BitAddress = __readcr3();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Shift the address by 12 bits */</span></span><br><span class="line">physical.QuadPart = cr3.Bits.PhysicalAddress &lt;&lt; PAGE_4KB_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the physical address and convert it to a virtual address, storing it in a PML4 structure */</span></span><br><span class="line">pml4_base.BitAddress = MmGetVirtualForPhysical( physical );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Validate the resulting address */</span></span><br><span class="line"><span class="keyword">if</span> ( !MmIsAddressValid( pml4_base.BitAddress ) || !pml4_base.BitAddress )</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>Lets quickly explain some things, first we need to left shift the <code>cr3</code> value by 12, since bits <code>47:12</code> contain the actual physical address. Secondly, the reason we use <code>MmGetVirtualForPhysical</code> rather then mapping the tables to our address space and simply reading them is because Windows prevents the mapping of page tables using functions such as <code>MmMapIoSpace</code>, <code>MmCopyMemory</code> and <code>ZwMapViewOfSection</code> meaning we must use <code>MmGetVirtualForPhysical</code> to get the equivalent virtual address. Now that we have our base <code>PML4</code> virtual address, we need to iterate through each entry in the table:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PML4 table has 512 entries */</span></span><br><span class="line"><span class="keyword">for</span> ( INT pml4_index = <span class="number">0</span>; pml4_index &lt; PML4_ENTRY_COUNT; pml4_index++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Validate address, can never be too safe */</span></span><br><span class="line"><span class="keyword">if</span> ( !MmIsAddressValid( pml4_base.BitAddress + pml4_index * <span class="keyword">sizeof</span>( UINT64 ) ) )</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the entry by simply dereferencing it */</span></span><br><span class="line">pml4_entry.BitAddress = *( UINT64* )( pml4_base.BitAddress + pml4_index * <span class="keyword">sizeof</span>( UINT64 ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the page is present */</span></span><br><span class="line"><span class="keyword">if</span> ( pml4_entry.Bits.Present == <span class="literal">NULL</span> )</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* retrieve the subset physical address from our pml4e and shift by 12 bits */</span></span><br><span class="line">physical.QuadPart = pml4_entry.Bits.PhysicalAddress &lt;&lt; PAGE_4KB_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* retrieve the equivalent virtual address and store it */</span></span><br><span class="line">pdpt_base = MmGetVirtualForPhysical( physical );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* validate resulting address */</span></span><br><span class="line"><span class="keyword">if</span> ( !pdpt_base || !MmIsAddressValid( pdpt_base ) )</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>Here we iterate through each address in the table, at each index we dereference the value to get the (among other things) the physical address of the next paging structure. However, first we make sure the present bit is set which tells us if the page is present in memory. We then proceed to follow the same steps as in the previous block of code to retrieve the next paging structures base virtual address, in this case we retrieve the <code>PDPT</code> base. The general process is the same for the remaining paging structures, however there are some things you need to consider.</p>
<!-- TOC --><a name="large-pages"></a>
<h3 id="Large-Pages"><a href="#Large-Pages" class="headerlink" title="Large Pages"></a>Large Pages</h3><p>Not every page is <code>4096</code> bytes in size, a <code>PDPT</code> entry can point to a <code>1GB</code> sized page and a <code>PD</code> entry can point to a <code>2MB</code> sized page. For our case these pages arent relevant since a process allocation will always reside inside a standard <code>4096</code> sized page, but it is important to note if you are using this method to scan for larger allocations. The 7th bit in both the <code>PD</code> entry and the <code>PDPT</code> entry will tell you if they point to a large page. </p>
<p>Once we have our <code>PT</code> base and want to iterate through each entry, there is an extra step involved:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( INT pt_index = <span class="number">0</span>; pt_index &lt; PT_ENTRY_COUNT; pt_index++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !MmIsAddressValid( pt_base + pt_index * <span class="keyword">sizeof</span>( UINT64 ) ) )</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  pt_entry.BitAddress = *( UINT64* )( pt_base + pt_index * <span class="keyword">sizeof</span>( UINT64 ) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( pt_entry.Bits.Present == <span class="literal">NULL</span> )</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This will get us the physical address of the base of the page */</span></span><br><span class="line">  physical.QuadPart = pt_entry.Bits.PhysicalAddress &lt;&lt; PAGE_4KB_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* validate that the page is in the valid physical memory range */</span></span><br><span class="line">  <span class="keyword">if</span> ( IsPhysicalAddressInPhysicalMemoryRange( physical.QuadPart, physical_memory_ranges ) == FALSE )</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* retrieve the equivalent virtual address of the page */</span></span><br><span class="line">  base_virtual_page = MmGetVirtualForPhysical( physical );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !base_virtual_page || !MmIsAddressValid( base_virtual_page ) )</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Perform a pattern scan on the page for process allocations */</span></span><br><span class="line">  ScanPageForKernelObjectAllocation(</span><br><span class="line">    base_virtual_page,</span><br><span class="line">    PAGE_BASE_SIZE,</span><br><span class="line">    INDEX_PROCESS_POOL_TAG,</span><br><span class="line">    AddressBuffer</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- TOC --><a name="physical-memory-ranges"></a>
<h3 id="Physical-Memory-Ranges"><a href="#Physical-Memory-Ranges" class="headerlink" title="Physical Memory Ranges"></a>Physical Memory Ranges</h3><p>Before we finally pass the page to <code>ScanPageForKernelObjectAllocation</code>, we pass the physical address to <code>IsPhysicalAddressInPhysicalMemoryRange</code>. This function performs the following:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">IsPhysicalAddressInPhysicalMemoryRange</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ UINT64 PhysicalAddress,</span></span><br><span class="line"><span class="params">  _In_ PPHYSICAL_MEMORY_RANGE PhysicalMemoryRanges</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">  ULONG page_index = <span class="number">0</span>;</span><br><span class="line">  UINT64 start_address = <span class="number">0</span>;</span><br><span class="line">  UINT64 end_address = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( PhysicalMemoryRanges[ page_index ].NumberOfBytes.QuadPart != <span class="literal">NULL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    start_address = PhysicalMemoryRanges[ page_index ].BaseAddress.QuadPart;</span><br><span class="line">    end_address = start_address + PhysicalMemoryRanges[ page_index ].NumberOfBytes.QuadPart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( PhysicalAddress &gt;= start_address &amp;&amp; PhysicalAddress &lt;= end_address )</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    page_index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>PPHYSICAL_MEMORY_RANGE</code> pointer is a set of <code>PHYSICAL_MEMORY_RANGE</code> structures returned by the Windows function <code>MmGetPhysicalMemoryRangesEx2</code>. These structures have the following definition:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PHYSICAL_MEMORY_RANGE</span> &#123;</span></span><br><span class="line">    PHYSICAL_ADDRESS BaseAddress;</span><br><span class="line">    LARGE_INTEGER NumberOfBytes;</span><br><span class="line">&#125; PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;</span><br></pre></td></tr></table></figure>

<p>Here we validate that the pages physical base address lies within the valid physical range of the operating system (i.e valid physical memory assigned to the operating system). Once we validate the page is in the operating systems physical memory range, we are then safe to proceed to perform a signature scan on said page.</p>
<!-- TOC --><a name="scanning-a-page-for-process-allocations"></a>
<h2 id="Scanning-a-Page-For-Process-Allocations"><a href="#Scanning-a-Page-For-Process-Allocations" class="headerlink" title="Scanning a Page For Process Allocations"></a>Scanning a Page For Process Allocations</h2><p>Now that we have a page we can scan for our process signature, lets walk through the implementation.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">ScanPageForKernelObjectAllocation</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ UINT64 PageBase,</span></span><br><span class="line"><span class="params">  _In_ ULONG PageSize,</span></span><br><span class="line"><span class="params">  _In_ ULONG ObjectIndex,</span></span><br><span class="line"><span class="params">  _In_ PVOID AddressBuffer</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">  INT length = <span class="number">0</span>;</span><br><span class="line">  CHAR current_char;</span><br><span class="line">  CHAR current_sig_byte;</span><br><span class="line">  PPOOL_HEADER pool_header;</span><br><span class="line">  PEPROCESS process = <span class="literal">NULL</span>;</span><br><span class="line">  PEPROCESS process_size_one = <span class="literal">NULL</span>;</span><br><span class="line">  PEPROCESS process_size_two = <span class="literal">NULL</span>;</span><br><span class="line">  PEPROCESS test_process = <span class="literal">NULL</span>;</span><br><span class="line">  LPCSTR process_name;</span><br><span class="line">  PUINT64 address_list;</span><br><span class="line">  ULONG allocation_size;</span><br><span class="line">  ULONG minimum_process_allocation_size = EPROCESS_SIZE - <span class="keyword">sizeof</span>( POOL_HEADER ) - OBJECT_HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !PageBase || !PageSize )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we reach a point in the page where a process can no longer be allocated, return */</span></span><br><span class="line">  <span class="keyword">for</span> ( INT offset = <span class="number">0</span>; offset &lt;= PageSize - POOL_TAG_LENGTH - minimum_process_allocation_size; offset++ )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( INT sig_index = <span class="number">0</span>; sig_index &lt; POOL_TAG_LENGTH + <span class="number">1</span>; sig_index++ )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !MmIsAddressValid( PageBase + offset + sig_index ) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* check the current character against the signature character */</span></span><br><span class="line">      current_char = *( PCHAR )( PageBase + offset + sig_index );</span><br><span class="line">      current_sig_byte = EXECUTIVE_OBJECT_POOL_TAGS[ ObjectIndex ][ sig_index ];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* if we&#x27;ve found 4 matching characters, proceed */</span></span><br><span class="line">      <span class="keyword">if</span> ( sig_index == POOL_TAG_LENGTH )</span><br><span class="line">      &#123;</span><br><span class="line">        pool_header = ( UINT64 )PageBase + offset - POOL_TAG_OFFSET;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !MmIsAddressValid( ( PVOID )pool_header ) )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* because process allocations can have a variable number of headers, parse a pointer</span></span><br><span class="line"><span class="comment">         * incrementing it by 0x10 (since each headers size is divisible by 0x10). */</span></span><br><span class="line">        <span class="keyword">for</span> ( ULONG header_size = <span class="number">0x00</span>; header_size &lt; <span class="number">0xb0</span>; header_size += <span class="number">0x10</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          test_process = ( PEPROCESS )( ( UINT64 )pool_header + <span class="keyword">sizeof</span>( POOL_HEADER ) + header_size );</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* if the test pointer passes the tests, confirm we&#x27;ve (probably) found a process allocation</span></span><br><span class="line"><span class="comment">           * and break out of the loop. */</span></span><br><span class="line">          <span class="keyword">if</span> ( ValidateIfAddressIsProcessStructure( test_process, pool_header ) )</span><br><span class="line">          &#123;</span><br><span class="line">            process = test_process;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( process == <span class="literal">NULL</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        DEBUG_LOG( <span class="string">&quot;Process: %llx&quot;</span>, (UINT64)process );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( current_char != current_sig_byte )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, the part that differs from a regular signature scan is the following loop:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ULONG header_size = <span class="number">0x30</span>; header_size &lt; <span class="number">0xb0</span>; header_size += <span class="number">0x10</span> )</span><br><span class="line">&#123;</span><br><span class="line">  test_process = ( PEPROCESS )( ( UINT64 )pool_header + <span class="keyword">sizeof</span>( POOL_HEADER ) + header_size );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( ValidateIfAddressIsProcessStructure( test_process, pool_header ) )</span><br><span class="line">  &#123;</span><br><span class="line">    process = test_process;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here rather then hard coding the object header size for the <code>EPROCESS</code> structure, we are iterating through every possible header combination. While this does increase the running time of the scan, I believe its an important step rather then hardcoding the <code>EPROCESS</code> header object size which could differ in previous or future major versions of Windows. So with each pool header, we scan with increasing header object sizes starting from <code>0x30</code> (size of <code>OBJECT_HEADER</code>) which is required for every object, up until <code>0xb0</code> which is equal to the total size of all possible headers + <code>0x10</code> as a buffer for potential padding. Now it is important to note that even with the performance penalty the scanning still takes at a maximum around ~ 2 seconds on my real machine (non-vm) with 32gbs of memory. You are more then welcome to offer any optimisation suggestions and&#x2F;or experiement with alternative methods yourself. From here, we now need to build the <code>ValidateIfAddressIsProcessStructure</code> function with our <code>EPROCESS</code> signature to determine whether the pointer passed in is indeed a valid process allocation.</p>
<!-- TOC --><a name="building-a-process-signature"></a>
<h2 id="Building-a-Process-Signature"><a href="#Building-a-Process-Signature" class="headerlink" title="Building a Process Signature"></a>Building a Process Signature</h2><p>Firstly, lets define a process signature as a way of identifying process allocations using fields from the <code>EPROCESS/KPROCESS</code> structure that remain consistent across both major and minor versions of Windows as well as reducing false positives which could have a similar memory signature.</p>
<!-- TOC --><a name="finding-the-robust-fields"></a>
<h3 id="Finding-the-Robust-Fields"><a href="#Finding-the-Robust-Fields" class="headerlink" title="Finding the Robust Fields"></a>Finding the Robust Fields</h3><p>A study was published titled <strong>Robust Signatures for Kernel Data Structures</strong> with the goal of finding a robust signature for the <code>EPROCESS</code> structure. You can find the study <a target="_blank" rel="noopener" href="https://www.cise.ufl.edu/~traynor/papers/ccs09b.pdf">here</a>. Using this as a source, they found the fields that were accessed the most to ensure those fields were actually used by the OS and then used a signature generator to find constraint templates across their data set. This was the result:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+-------------------------------------------------------------------+</span><br><span class="line">| Field Constraint            | Condition                                                         |</span><br><span class="line">+-----------------------------+-------------------------------------------------------------------+</span><br><span class="line">| Pcb.ReadyListHead.Flink     | val &amp; <span class="number">0x80000000</span> == <span class="number">0x80000000</span> &amp;&amp; val % <span class="number">0x8</span> == <span class="number">0</span>                  |</span><br><span class="line">| Pcb.ThreadListHead.Flink    | val &amp; <span class="number">0x80000000</span> == <span class="number">0x80000000</span> &amp;&amp; val % <span class="number">0x8</span> == <span class="number">0</span>                  |</span><br><span class="line">| WorkingSetLock.Count        | val == <span class="number">1</span> &amp;&amp; val &amp; <span class="number">0x1</span> == <span class="number">0x1</span>                                      |</span><br><span class="line">| Vm.VmWorkingSetList         | val &amp; <span class="number">0xc0003000</span> == <span class="number">0xc0003000</span> &amp;&amp; val % <span class="number">0x1000</span> == <span class="number">0</span>               |</span><br><span class="line">| VadRoot                     | val == <span class="number">0</span> || (val &amp; <span class="number">0x80000000</span> == <span class="number">0x80000000</span> &amp;&amp; val % <span class="number">0x8</span> == <span class="number">0</span>)    |</span><br><span class="line">| Token.Value                 | val &amp; <span class="number">0xe0000000</span> == <span class="number">0xe0000000</span>                                    |</span><br><span class="line">| AddressCreationLock.Count   | val == <span class="number">1</span> &amp;&amp; val &amp; <span class="number">0x1</span> == <span class="number">0x1</span>                                      |</span><br><span class="line">| VadHint                     | val == <span class="number">0</span> || (val &amp; <span class="number">0x80000000</span> == <span class="number">0x80000000</span> &amp;&amp; val % <span class="number">0x8</span> == <span class="number">0</span>)    |</span><br><span class="line">| Token.Object                | val &amp; <span class="number">0xe0000000</span> == <span class="number">0xe0000000</span>                                    |</span><br><span class="line">| QuotaBlock                  | val &amp; <span class="number">0x80000000</span> == <span class="number">0x80000000</span> &amp;&amp; val % <span class="number">0x8</span> == <span class="number">0</span>                  |</span><br><span class="line">| ObjectTable                 | val == <span class="number">0</span> || (val &amp; <span class="number">0xe0000000</span> == <span class="number">0xe0000000</span> &amp;&amp; val % <span class="number">0x8</span> == <span class="number">0</span>)    |</span><br><span class="line">| GrantedAccess               | val &amp; <span class="number">0x1f07fb</span> == <span class="number">0x1f07fb</span>                                        |</span><br><span class="line">| ActiveProcessLinks.Flink    | val &amp; <span class="number">0x80000000</span> == <span class="number">0x80000000</span> &amp;&amp; val % <span class="number">0x8</span> == <span class="number">0</span>                  |</span><br><span class="line">| Peb                         | val == <span class="number">0</span> || (val &amp; <span class="number">0x7ffd0000</span> == <span class="number">0x7ffd0000</span> &amp;&amp; val % <span class="number">0x1000</span> == <span class="number">0</span>) |</span><br><span class="line">| Pcb.DirectoryTableBase<span class="number">.0</span>    | val % <span class="number">0x20</span> == <span class="number">0</span>                                                   |</span><br><span class="line">+-----------------------------+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>Using these findings, we can build our own signature as well as introduce some other contraints since we are only focused on finding actively running processes rather then terminated processes.</p>
<!-- TOC --><a name="building-our-signature"></a>
<h3 id="Building-our-signature"><a href="#Building-our-signature" class="headerlink" title="Building our signature"></a>Building our signature</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">ValidateIfAddressIsProcessStructure</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ PVOID Address,</span></span><br><span class="line"><span class="params">  _In_ PPOOL_HEADER PoolHeader</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">  UINT64 peak_virtual_size = <span class="literal">NULL</span>;</span><br><span class="line">  UINT64 dir_table_base = <span class="literal">NULL</span>;</span><br><span class="line">  UINT64 allocation_size = <span class="literal">NULL</span>;</span><br><span class="line">  UINT64 peb = <span class="literal">NULL</span>;</span><br><span class="line">  UINT64 object_table = <span class="literal">NULL</span>;</span><br><span class="line">  BOOLEAN peb_test = FALSE;</span><br><span class="line">  BOOLEAN object_table_test = FALSE;</span><br><span class="line">  UINT64 allocation_size_test = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( MmIsAddressValid( ( UINT64 )Address + KPROCESS_DIRECTORY_TABLE_BASE_OFFSET ) )</span><br><span class="line">    dir_table_base = *( UINT64* )( ( UINT64 )Address + KPROCESS_DIRECTORY_TABLE_BASE_OFFSET );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( MmIsAddressValid( ( UINT64 )Address + EPROCESS_PEAK_VIRTUAL_SIZE_OFFSET ) )</span><br><span class="line">    peak_virtual_size = *( UINT64* )( ( UINT64 )Address + EPROCESS_PEAK_VIRTUAL_SIZE_OFFSET );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( MmIsAddressValid( ( UINT64 )PoolHeader + POOL_HEADER_BLOCK_SIZE_OFFSET ) )</span><br><span class="line">    allocation_size = PoolHeader-&gt;BlockSize * CHUNK_SIZE - <span class="keyword">sizeof</span>( POOL_HEADER );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( MmIsAddressValid( ( UINT64 )Address + EPROCESS_PEB_OFFSET ) )</span><br><span class="line">    peb = *( UINT64* )( ( UINT64 )Address + EPROCESS_PEB_OFFSET );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( MmIsAddressValid((UINT64)Address + EPROCESS_OBJECT_TABLE_OFFSET ) )</span><br><span class="line">    object_table = *( UINT64* )( ( UINT64 )Address + EPROCESS_OBJECT_TABLE_OFFSET );</span><br><span class="line"></span><br><span class="line">  peb_test = peb == <span class="literal">NULL</span> || ( peb &amp; <span class="number">0x7ffd0000</span> == <span class="number">0x7ffd0000</span> &amp;&amp; peb % <span class="number">0x1000</span> == <span class="literal">NULL</span> );</span><br><span class="line">  object_table_test = object_table == <span class="literal">NULL</span> || ( object_table &amp; <span class="number">0xe0000000</span> == <span class="number">0xe0000000</span> &amp;&amp; object_table % <span class="number">0x8</span> == <span class="number">0</span> );</span><br><span class="line">  allocation_size_test = allocation_size &amp; <span class="number">0xfff0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( peak_virtual_size &gt; <span class="number">0</span> &amp;&amp; ( dir_table_base &amp; <span class="number">0x20</span> ) == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    allocation_size &gt; ( EPROCESS_SIZE + OBJECT_HEADER_SIZE + <span class="keyword">sizeof</span>( POOL_HEADER ) ) &amp;&amp;</span><br><span class="line">    PoolHeader-&gt;PoolType != <span class="literal">NULL</span> &amp;&amp; !( allocation_size_test == <span class="number">0xfff0</span> ) &amp;&amp; !peb_test &amp;&amp; !object_table_test )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lets examine some of the constraints </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( dir_table_base &amp; <span class="number">0x20</span> ) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>The <code>EPROCESS-&gt;DirectoryTableBase</code> must be <code>0x20</code> aligned.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(allocation_size_test = allocation_size &amp; <span class="number">0xfff0</span>) == <span class="number">0xfff0</span>);</span><br></pre></td></tr></table></figure>

<p>Here we are filtering out allocation sizes equal to <code>0xffffffffffff0</code> or a subset of.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation_size &gt; EPROCESS_SIZE + OBJECT_HEADER_SIZE + <span class="keyword">sizeof</span>(POOL_HEADER)</span><br></pre></td></tr></table></figure>

<p>The allocation size must be greater then the minimum size required to allocate an <code>EPROCESS</code> structure.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PoolHeader-&gt;PoolType != <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>The <code>PoolHeader-&gt;PoolType</code> must not be <code>NULL</code></p>
<p>The PEB and object table constraints are from the signatures generated from the study noted above. Adding these all together gives us an extremely accurate way of identifying running processes via memory scanning. If these constraints are met, we return <code>TRUE</code> letting the caller know that we can say with a high degree of confidence it is indeed a process allocation.</p>
<!-- TOC --><a name="results"></a>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>Putting a <code>__debugbreak()</code> at right at the end of scanning allows us to break execution as close as possible to the scanning to ensure when we enumerate processes using the WinDbg <code>!process</code> command we minimise the time difference between scanning and enumerating processes. Below is a portion of the results, of all 131 actively running processes all 131 were found with the exact same <code>EPROCESS</code> base address.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+------------------+------------------+</span><br><span class="line">| Our Results      | !process <span class="number">0</span> <span class="number">0</span>     |     </span><br><span class="line">+------------------+------------------+</span><br><span class="line">| ffffde09ac175080 | ffffde09ac175080 |</span><br><span class="line">| ffffde09ac17e080 | ffffde09ac17e080 |</span><br><span class="line">| ffffde09ac182080 | ffffde09ac182080 |</span><br><span class="line">| ffffde09ac1aa080 | ffffde09ac1aa080 |</span><br><span class="line">| ffffde09acc03080 | ffffde09acc03080 |</span><br><span class="line">| ffffde09aed75040 | ffffde09aed75040 |</span><br><span class="line">| ffffde09b0ecd080 | ffffde09b0ecd080 |</span><br><span class="line">| ffffde09b1121080 | ffffde09b1121080 |</span><br><span class="line">| ffffde09b1160140 | ffffde09b1160140 |</span><br><span class="line">| ffffde09b1a020c0 | ffffde09b1a020c0 |</span><br><span class="line">| ffffde09b1a0e080 | ffffde09b1a0e080 |</span><br><span class="line">| ffffde09b1a2b080 | ffffde09b1a2b080 |</span><br><span class="line">| ffffde09b1aa6240 | ffffde09b1aa6240 |</span><br><span class="line">| ffffde09b1ab2140 | ffffde09b1ab2140 |</span><br><span class="line">| ffffde09b1eb22c0 | ffffde09b1eb22c0 |</span><br><span class="line">| ffffde09b1f16080 | ffffde09b1f16080 |</span><br><span class="line">| ffffde09b1f1e300 | ffffde09b1f1e300 |</span><br><span class="line">| ffffde09b2040240 | ffffde09b2040240 |</span><br><span class="line">| ffffde09b20582c0 | ffffde09b20582c0 |</span><br><span class="line">| ffffde09b205f300 | ffffde09b205f300 |</span><br><span class="line">| ffffde09b2065280 | ffffde09b2065280 |</span><br><span class="line">| ffffde09b20d0280 | ffffde09b20d0280 |</span><br><span class="line">| ffffde09b20d3300 | ffffde09b20d3300 |</span><br><span class="line">| ffffde09b2114240 | ffffde09b2114240 |</span><br><span class="line">| ffffde09b211d280 | ffffde09b211d280 |</span><br><span class="line">| ffffde09b211f2c0 | ffffde09b211f2c0 |</span><br><span class="line">| ffffde09b21782c0 | ffffde09b21782c0 |</span><br><span class="line">| ffffde09b2450300 | ffffde09b2450300 |</span><br><span class="line">| ...              | ...              |</span><br><span class="line">+------------------+------------------+</span><br></pre></td></tr></table></figure>

<p>Now with something like this there will always be false positives, for example a process that has been scanned could be terminated before we can enumerate the process list meaning our lists will differ. As with anything in memory forensics there should be some manual investigation, so allowing for some false-positives that you can then analyse later is important. In this case, we simply copy the <code>EPROCESS</code> structure from memory and send it in an IRP for later analysis. You could potentially run the scanning thread aswell as another thread which manually walks the process list at the same time to minimise the chance for processes to be terminated during the scan. Just an idea! </p>
<!-- TOC --><a name="conclusion"></a>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>And that’s all there is too it! You now have a new tool in your arsenal in the world of memory forensics. This is an excellent method in finding unlinked running processes, commonly seen in rootkits and bootkits and malware in general. The full source code will be up on my github shortly, I will update this when its been uploaded. Thanks for reading and I hope you learnt something new about memory forensics! :)</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/projects/">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executive-Object-Header-Structure"><span class="toc-number">2.</span> <span class="toc-text">Executive Object Header Structure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-Header-Structure"><span class="toc-number">2.1.</span> <span class="toc-text">Object Header Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional-Headers"><span class="toc-number">2.2.</span> <span class="toc-text">Optional Headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Header-Structure"><span class="toc-number">2.3.</span> <span class="toc-text">Header Structure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-Pool-Allocations"><span class="toc-number">3.</span> <span class="toc-text">Windows Pool Allocations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pool-Header-Structure"><span class="toc-number">3.1.</span> <span class="toc-text">Pool Header Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocation-Pool-Tags"><span class="toc-number">3.2.</span> <span class="toc-text">Allocation Pool Tags</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#An-Introduction-to-Memory-Paging"><span class="toc-number">4.</span> <span class="toc-text">An Introduction to Memory Paging</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intel-Paging-Structure"><span class="toc-number">4.1.</span> <span class="toc-text">Intel Paging Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-Address-structure"><span class="toc-number">4.2.</span> <span class="toc-text">Virtual Address structure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Table-Walking-on-Modern-Windows"><span class="toc-number">5.</span> <span class="toc-text">Page Table Walking on Modern Windows</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Pages"><span class="toc-number">5.1.</span> <span class="toc-text">Large Pages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Physical-Memory-Ranges"><span class="toc-number">5.2.</span> <span class="toc-text">Physical Memory Ranges</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanning-a-Page-For-Process-Allocations"><span class="toc-number">6.</span> <span class="toc-text">Scanning a Page For Process Allocations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-a-Process-Signature"><span class="toc-number">7.</span> <span class="toc-text">Building a Process Signature</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Finding-the-Robust-Fields"><span class="toc-number">7.1.</span> <span class="toc-text">Finding the Robust Fields</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Building-our-signature"><span class="toc-number">7.2.</span> <span class="toc-text">Building our signature</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Results"><span class="toc-number">8.</span> <span class="toc-text">Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">9.</span> <span class="toc-text">Conclusion</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&text=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&is_video=false&description=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=How to Scan Physical Memory to Find Windows Process Allocations&body=Check out this article: https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&title=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&name=How to Scan Physical Memory to Find Windows Process Allocations&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://donnaskiez.dev/2023/09/07/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/&t=How to Scan Physical Memory to Find Windows Process Allocations"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    <a style="text-decoration:none; scale = 1.5;" target="_blank" rel="noopener" href="https://github.com/donnaskiez" class="fa-brands fa-github"></a>
    <a style="text-decoration:none;" target="_blank" rel="noopener" href="https://twitter.com/donnaskiez" class="fa-brands fa-twitter"></a>
    <a style="text-decoration:none;" target="_blank" rel="noopener" href="https://www.linkedin.com/in/lachlan-hodges-818210244/" class="fa-brands fa-linkedin"></a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/projects/">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
