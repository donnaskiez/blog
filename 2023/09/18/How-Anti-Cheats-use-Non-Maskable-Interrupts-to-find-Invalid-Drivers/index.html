<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="RationaleAs the methods employed by anti cheat programs to detect cheating continuously improve year after year, it forces the game hacking community to reach for some more advanced weaponary in orde">
<meta property="og:type" content="article">
<meta property="og:title" content="How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers">
<meta property="og:url" content="http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/index.html">
<meta property="og:site_name" content="donnaskiez.dev">
<meta property="og:description" content="RationaleAs the methods employed by anti cheat programs to detect cheating continuously improve year after year, it forces the game hacking community to reach for some more advanced weaponary in orde">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://donnaskiez.github.io/blog/images/nmiimage.png">
<meta property="article:published_time" content="2023-09-18T12:44:45.000Z">
<meta property="article:modified_time" content="2023-09-18T15:50:37.935Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Windows Internals">
<meta property="article:tag" content="Anti-Cheat">
<meta property="article:tag" content="Kernel Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://donnaskiez.github.io/blog/images/nmiimage.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/09/18/How-to-Scan-Physical-Memory-to-Find-Windows-Process-Allocations/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&text=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&is_video=false&description=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers&body=Check out this article: http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&name=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&t=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rationale"><span class="toc-number">1.</span> <span class="toc-text">Rationale</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flaws-with-Manual-Mapping"><span class="toc-number">2.</span> <span class="toc-text">Flaws with Manual Mapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-Kernel-Code-Execution-Bounds"><span class="toc-number">3.</span> <span class="toc-text">Windows Kernel Code Execution Bounds</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-Interrupts-and-Windows-IRQL"><span class="toc-number">4.</span> <span class="toc-text">CPU Interrupts and Windows IRQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-CPU-Interrupt"><span class="toc-number">4.1.</span> <span class="toc-text">What is a CPU Interrupt?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-IRQL"><span class="toc-number">4.2.</span> <span class="toc-text">Windows IRQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-Context"><span class="toc-number">5.</span> <span class="toc-text">Thread Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APCs-vs-DPCs"><span class="toc-number">6.</span> <span class="toc-text">APCs vs DPCs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-our-callback-routine"><span class="toc-number">7.</span> <span class="toc-text">Building our callback routine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-our-NMI-Callback-context"><span class="toc-number">7.1.</span> <span class="toc-text">Defining our NMI Callback context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-processor-affinity"><span class="toc-number">7.2.</span> <span class="toc-text">What is processor affinity?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Firing-an-NMI"><span class="toc-number">7.3.</span> <span class="toc-text">Firing an NMI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-Stack-Walking"><span class="toc-number">8.</span> <span class="toc-text">What is Stack Walking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-Stack-Walk-on-Windows"><span class="toc-number">9.</span> <span class="toc-text">How to Stack Walk on Windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Processing-the-Stack-Walk"><span class="toc-number">10.</span> <span class="toc-text">Processing the Stack Walk</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Lachlan Hodges</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-09-18T12:44:45.000Z" class="dt-published" itemprop="datePublished">2023-09-18</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Anti-Cheat/" rel="tag">Anti-Cheat</a>, <a class="p-category" href="/tags/Kernel-Programming/" rel="tag">Kernel Programming</a>, <a class="p-category" href="/tags/Windows-Internals/" rel="tag">Windows Internals</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <!-- TOC --><a name="rationale"></a>
<h2 id="Rationale"><a href="#Rationale" class="headerlink" title="Rationale"></a>Rationale</h2><p>As the methods employed by anti cheat programs to detect cheating continuously improve year after year, it forces the game hacking community to reach for some more advanced weaponary in order to evade this ever increasing protection. Over the last few years, the kernel has become the new home for both cheat detection and anti cheat evasion. Now if you have ever looked into developing a kernel driver for Windows, you’ll quickly find that in order for you to be able to load your driver on a machine without enabling test mode, you must get your driver signed by Microsoft or from one of the various companies that offer 3rd party driver signings. This signature, however, comes at a cost - and it isn’t cheap, with the cheapest driver signing services starting at around ~$250 USD</p>
<p>Now for your regular driver developer, this is completely fine and actually makes complete sense from a security perspective - as a driver has access to the entire address space of the machine essentially giving it free rein over everything on the system. However, game hackers who are looking to write a driver specifically with the intention of hacking a game must remember that as soon as an anti-cheat blacklists the driver it is over and the money spent is down the drain. To circumnavigate this, cheat manufacturers started to use a method known as manual mapping.</p>
<!-- TOC --><a name="flaws-with-manual-mapping"></a>
<h2 id="Flaws-with-Manual-Mapping"><a href="#Flaws-with-Manual-Mapping" class="headerlink" title="Flaws with Manual Mapping"></a>Flaws with Manual Mapping</h2><p>Now you might have heard of manual mapping a DLL, but instead they are manual mapping a system driver. While the specific details on how manually mapping a driver works is out of the scope of this article, what’s important to know is that the process of manually mapping a driver involves performing all operations of loading a module into memory by hand, or “manually” mapping it into memory. This allows you to load a module into memory bypassing any required win32 api calls such as <code>ZwMapViewOfSection</code>. So where is the flaw in this? Well, as with most major Windows data structures, loaded system drivers (known as system modules) are stored in a linked list within the kernel. This linked list is identfied with the name <code>PsLoadedModuleList</code>. Each entry contains the following information:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MODULE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HANDLE Section;</span><br><span class="line">    PVOID MappedBase;</span><br><span class="line">    PVOID ImageBase;</span><br><span class="line">    ULONG ImageSize;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadOrderIndex;</span><br><span class="line">    USHORT InitOrderIndex;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT OffsetToFileName;</span><br><span class="line">    UCHAR FullPathName[<span class="number">256</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>When you manual map a module, your module is <em>not</em> added to this list. Now why does this matter? Well, if we take a look at the <code>_SYSTEM_MODULE_ENTRY</code> structure, we can see that there are two fields important to us: the <code>ImageBase</code> which is a pointer the base of the module, and the <code>ImageSize</code> which specifies the module size in bytes. Now at this point it might not appear why these two fields are so important, but keep them in mind as we explore some other fundamental Windows components and you might begin to see <em>why</em> they are so critical.</p>
<!-- TOC --><a name="windows-kernel-code-execution-bounds"></a>
<h2 id="Windows-Kernel-Code-Execution-Bounds"><a href="#Windows-Kernel-Code-Execution-Bounds" class="headerlink" title="Windows Kernel Code Execution Bounds"></a>Windows Kernel Code Execution Bounds</h2><p>The Windows kernel - in simple terms - is simply another program that executes on the computer just like anything else. The kernel itself is called <code>ntoskrnl.exe</code> and is the main driver of the windows operating system as well as being the first entry in the <code>PsLoadedModuleList</code>. This is where the majority of kernel code execution will occur alongside any other loaded drivers and (in rare cases) the EFI runtime services. What’s important to note here, is that if you took a snapshot of every thread on the system (remember that windows, as with essentially every modern operating system, uses a one-to-one threading model) executing in kernel mode, almost every single instruction pointer would be pointing to an executable section inside <code>ntoskrnl.exe</code>. In all other cases, you would have an address that lies within a loaded module - for example a mouse driver - and in the rare case the EFI runtime service. This however is out of the scope of this article. Now if we recall how we were talking about the fact that:</p>
<ol>
<li>Manually mapping a module does not place it in the <code>PsLoadedModuleList</code></li>
<li>All kernel code execution occurs within the bounds of modules in the <code>PsLoadedModuleList</code></li>
<li>Each entry in this list contains a pointer to the module base and its size in bytes</li>
</ol>
<p>This means, that given an instruction pointer, we can iterate through every module in the <code>PsLoadedModuleList</code>, check if the instruction pointer lies within the bounds of module using the <code>ImageBase</code> and <code>ImageSize</code> fields and if there are no modules that contain the instruction pointer - we can argue with a high degree of certainty that we indeed have found a manually mapped driver. So we have figured out how we can do this given an instruction pointer, but how do we get said instruction pointer? Lets first delve into some operating systems fundamentals.</p>
<!-- TOC --><a name="cpu-interrupts-and-windows-irql"></a>
<h2 id="CPU-Interrupts-and-Windows-IRQL"><a href="#CPU-Interrupts-and-Windows-IRQL" class="headerlink" title="CPU Interrupts and Windows IRQL"></a>CPU Interrupts and Windows IRQL</h2><!-- TOC --><a name="what-is-a-cpu-interrupt"></a>
<h3 id="What-is-a-CPU-Interrupt"><a href="#What-is-a-CPU-Interrupt" class="headerlink" title="What is a CPU Interrupt?"></a>What is a CPU Interrupt?</h3><p>The most basic definition of an Interrupt in our context, is a message sent from either a device attached to the computer or a program running on the computer to the processor indicating that an event must be processed. When an interrupt occurs, the processor will preempt the current thread and execute the operating systems interrupt handler depending on the type of interrupt. Once the interrupt has been processed, execution is returned to the thread that was interrupted. Now it is important to note that the kernel regularly disables interrupts to a processor - normally during critical operations involving state such as a context switch. When interrupts are disabled any new interrupts will not be processed until interrupts are enabled again allowing the processor to handle any pending interrupts that occured during the period they were disabled. There is, however, one interrupt which cannot be masked off - known as a non-maskable interrupt. Before we discuss the non-maskable interrupt, lets first explore how windows abstracts the idea of CPU interrupts.</p>
<!-- TOC --><a name="windows-irql"></a>
<h3 id="Windows-IRQL"><a href="#Windows-IRQL" class="headerlink" title="Windows IRQL"></a>Windows IRQL</h3><p>An IRQL or <em>interrupt request level</em> is how windows classifies the urgency of an interrupt. When a thread is running at a certain IRQL, any thread attempting to preempt the currently executing thread that is running below the threads IRQL will be <em>masked off</em>. The term <em>masked off</em> essentially means that the interrupt will be ignored until the threads IRQL has been lowered to atleast the interrupting threads IRQL. Below is a table describing the interrupts that matter most (there are a few missing, but they are irrelevant for this article).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------------+--------------------+----------------------------------------------+</span><br><span class="line">|   IRQL         |  IRQL <span class="title function_">Value</span> <span class="params">(x64)</span>  |  Description                                 |</span><br><span class="line">+----------------+--------------------+----------------------------------------------+</span><br><span class="line">| PASSIVE_LEVEL  | 0                  | User threads and most kernel operations      |</span><br><span class="line">| APC_LEVEL      | 1                  | Asynchronous procedure calls and page faults |</span><br><span class="line">| DISPATCH_LEVEL | 2                  | Thread scheduler and DPCs                    |</span><br><span class="line">| DIRQL          | 4-11               | Device Interrupts                            |</span><br><span class="line">| HIGH_LEVEL     | 15                 | Machine checks and catastrophic errors       |</span><br><span class="line">+----------------+--------------------+----------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>As the IRQL increases, the priority of that interrupt increases. For example, a thread running at <code>DISPATCH_LEVEL</code> will mask off all interrupts with an <code>IRQL &lt; DISPATCH_LEVEL</code> i.e all interrupts running at <code>APC_LEVEL</code> and <code>PASSIVE_LEVEL</code> will not be executed until all interrupts running at <code>IRQL &gt;= DISPATCH_LEVEL</code> have been handled and the thread lowers its IRQL. Now if we recall from the previous paragraph we briefly mentioned the non-maskable interrupt and how it can’t be masked off under any circumstances, what this means in the context of a Windows system is that the interrupt will run at an IRQL of <code>HIGH_LEVEL</code>, meaning it will preempt any and every thread running on the system - with no possibility of the interrupt being masked. </p>
<!-- TOC --><a name="thread-context"></a>
<h2 id="Thread-Context"><a href="#Thread-Context" class="headerlink" title="Thread Context"></a>Thread Context</h2><p>When a thread executes on a system, the thread is performing a set of operations on a set of CPU registers on a given processor. The state of these registers is critical to ensure the ensuing CPU instructions do not corrupt the system and perform the task as it were designed. When an interrupt occurs - either from an external source or because the threads time quantum has expired - the processor will perform whats called a context switch. A context switch is when the state of a thread is saved and stored either on the stack or the threads kernel object, in the case of Windows the <code>_KTHREAD</code> structure, and the new threads state is loaded and execution is continued. </p>
<!-- TOC --><a name="apcs-vs-dpcs"></a>
<h2 id="APCs-vs-DPCs"><a href="#APCs-vs-DPCs" class="headerlink" title="APCs vs DPCs"></a>APCs vs DPCs</h2><p>The reason we have quickly gone over thread context is because our goal is to execute a function <em>within</em> the context of another thread. To do so, we first need a way of issuing an interrupt towards a target thread which executes our own code, luckily for us windows calls these <em>procedure calls</em>. A <em>procedure call</em> allows us to queue our own function as an interrupt which will get executed by the target thread - with the main two options being an asynchronous procedure call and a deferred procedure call. Both allow us to queue our own function for execution targetting a particular target thread, however there are a few key differences between the two. The first being that DPCs run at <code>DISPATCH_LEVEL</code> and APCs run at <code>APC_LEVEL</code>, but the main difference we care about is that APCs execute within the context of the target thread, whereas a DPC does not. So this means we should just use an APC for the task right? Wrong. The reason APCs, while useful, should not be used is because they can simply be masked off by raising your threads IRQL to at or above <code>DISPATCH_LEVEL</code>. So this leaves us with the NMI as the best option for gaining execution within an interrupted threads context. Lets figure out how this can be done.</p>
<!-- TOC --><a name="building-our-callback-routine"></a>
<h2 id="Building-our-callback-routine"><a href="#Building-our-callback-routine" class="headerlink" title="Building our callback routine"></a>Building our callback routine</h2><p>Before we begin implenting our core business logic for our interrupt, we need to allocate some memory we can use during the callback.</p>
<!-- TOC --><a name="defining-our-nmi-callback-context"></a>
<h3 id="Defining-our-NMI-Callback-context"><a href="#Defining-our-NMI-Callback-context" class="headerlink" title="Defining our NMI Callback context"></a>Defining our NMI Callback context</h3><p>When our callback runs, we are going to need 3 things. First, the number of cores on our system, secondly a buffer to store the stack trace and finally a buffer to store any extra data we want to capture from the interrupted thread.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NMI_CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PVOID stack_frames;</span><br><span class="line">	PVOID thread_data;</span><br><span class="line">	INT core_count;</span><br><span class="line">&#125;NMI_CONTEXT, * PNMI_CONTEXT;</span><br></pre></td></tr></table></figure>

<p>Lets also define our thread data as the following, where we want to store the number of stack frames captured for that particular thread and the offset from the base of the stack frames buffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NMI_CALLBACK_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uintptr_t</span>	stack_frames_offset;</span><br><span class="line">	INT			num_frames_captured;</span><br><span class="line">&#125;NMI_CALLBACK_DATA, * PNMI_CALLBACK_DATA;</span><br></pre></td></tr></table></figure>

<p>Lets now define a function which handles an IOCTL code (you can implement that yourself) to trigger an NMI. Here, we allocate a buffer on the stack for our <code>NMI_CONTEXT</code> structure and get the core count using <code>KeQueryActiveProcessorCountEx(0)</code> passing in <code>0</code> as the parameter which will get us the total core count on the system.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">SetupAndRunNmiCallback</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	NMI_CONTEXT nmi_context = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	SYSTEM_MODULES system_modules = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	nmi_context.core_count = KeQueryActiveProcessorCountEx( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">	status = GetSystemModuleInformation( &amp;system_modules );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* ...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (system_modules.address)</span><br><span class="line">		ExFreePoolWithTag( system_modules.address, SYSTEM_MODULES_POOL );</span><br><span class="line">	<span class="keyword">if</span> (nmi_context.stack_frames )</span><br><span class="line">		ExFreePoolWithTag( nmi_context.stack_frames, STACK_FRAMES_POOL );</span><br><span class="line">	<span class="keyword">if</span> (nmi_context.thread_data_pool )</span><br><span class="line">		ExFreePoolWithTag( nmi_context.thread_data_pool, THREAD_DATA_POOL );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next you see we’ve called a function called <code>GetSystemModuleInformation</code>, this function takes in a pointer to a <code>SYSTEM_MODULES</code> structure defined as the following:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_MODULES</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PVOID address;</span><br><span class="line">	INT module_count;</span><br><span class="line">&#125;SYSTEM_MODULES, * PSYSTEM_MODULES;</span><br></pre></td></tr></table></figure>

<p>Where <code>address</code> is a pointer to a buffer storing a <code>module_count</code> number of <code>RTL_MODULE_EXTENDED_INFO</code> structures. <code>RTL_MODULE_EXTENDED_INFO</code> provides a brief description of a system module, including <code>ImageBase</code> and <code>ImageSize</code> which are critical to us defining the valid kernel address space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_MODULE_EXTENDED_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PVOID ImageBase;</span><br><span class="line">	ULONG ImageSize;</span><br><span class="line">	USHORT FileNameOffset;</span><br><span class="line">	CHAR FullPathName[<span class="number">0x100</span>];</span><br><span class="line">&#125; RTL_MODULE_EXTENDED_INFO, * PRTL_MODULE_EXTENDED_INFO;</span><br></pre></td></tr></table></figure>

<p>Next the definition for <code>GetSystemModuleDefinition</code> is as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">GetSystemModuleInformation</span><span class="params">( </span></span><br><span class="line"><span class="params">	_Out_ PSYSTEM_MODULES ModuleInformation </span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( !ModuleInformation )</span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">	ULONG size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* query system module information without an output buffer to get</span></span><br><span class="line"><span class="comment">	* number of bytes required to store all module info structures</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS( RtlQueryModuleInformation(</span><br><span class="line">		&amp;size,</span><br><span class="line">		<span class="keyword">sizeof</span>( RTL_MODULE_EXTENDED_INFO ),</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	) ) )</span><br><span class="line">	&#123;</span><br><span class="line">		DEBUG_ERROR( <span class="string">&quot;Failed to query module information&quot;</span> );</span><br><span class="line">		<span class="keyword">return</span> STATUS_ABANDONED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate a pool equal to the output size of RtlQueryModuleInformation */</span></span><br><span class="line">	PRTL_MODULE_EXTENDED_INFO driver_information = ExAllocatePool2(</span><br><span class="line">		POOL_FLAG_NON_PAGED,</span><br><span class="line">		size,</span><br><span class="line">		SYSTEM_MODULES_POOL</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !driver_information )</span><br><span class="line">	&#123;</span><br><span class="line">		DEBUG_ERROR( <span class="string">&quot;Failed to allocate pool LOL&quot;</span> );</span><br><span class="line">		<span class="keyword">return</span> STATUS_ABANDONED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Query the modules again this time passing a pointer to the allocated buffer */</span></span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS( RtlQueryModuleInformation(</span><br><span class="line">		&amp;size,</span><br><span class="line">		<span class="keyword">sizeof</span>( RTL_MODULE_EXTENDED_INFO ),</span><br><span class="line">		driver_information</span><br><span class="line">	) ) )</span><br><span class="line">	&#123;</span><br><span class="line">		DEBUG_ERROR( <span class="string">&quot;Failed lolz&quot;</span> );</span><br><span class="line">		ExFreePoolWithTag( driver_information, SYSTEM_MODULES_POOL );</span><br><span class="line">		<span class="keyword">return</span> STATUS_ABANDONED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store the buffer and module count in SYSTEM_MODULES pointer passed in as argument */</span></span><br><span class="line">	ModuleInformation-&gt;address = driver_information;</span><br><span class="line">	ModuleInformation-&gt;module_count = size / <span class="keyword">sizeof</span>( RTL_MODULE_EXTENDED_INFO );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above is simply using <code>RtlQueryModuleInformation</code> to query the system modules and storing the information received in a buffer. Next we need to define our function that actually runs the NMI on each core, lets define it as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">LaunchNonMaskableInterrupt</span><span class="params">( </span></span><br><span class="line"><span class="params">	_In_ PNMI_CONTEXT NmiContext</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( !NmiContext )</span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate a buffer which will store our KAFFINITY_EX structures, more on this shortly */</span></span><br><span class="line">	PKAFFINITY_EX proc_affinity_pool = </span><br><span class="line">		ExAllocatePool2( POOL_FLAG_NON_PAGED, <span class="keyword">sizeof</span>( KAFFINITY_EX ), PROC_AFFINITY_POOL );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !proc_affinity_pool )</span><br><span class="line">		<span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate a buffer to store our stack frames at an arbitrary size (0x200), one for each core */</span></span><br><span class="line">	NmiContext-&gt;stack_frames = </span><br><span class="line">		ExAllocatePool2( POOL_FLAG_NON_PAGED, NmiContext-&gt;core_count * STACK_FRAME_POOL_SIZE, STACK_FRAMES_POOL );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !NmiContext-&gt;stack_frames )</span><br><span class="line">	&#123;</span><br><span class="line">		ExFreePoolWithTag( ProcAffinityPool, PROC_AFFINITY_POOL );</span><br><span class="line">		<span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate a buffer to store our additional thread data, once again one per core */</span></span><br><span class="line">	NmiContext-&gt;thread_data_pool = </span><br><span class="line">		ExAllocatePool2( POOL_FLAG_NON_PAGED, NmiContext-&gt;core_count * <span class="keyword">sizeof</span>( NMI_CALLBACK_DATA ), THREAD_DATA_POOL );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !NmiContext-&gt;thread_data_pool )</span><br><span class="line">	&#123;</span><br><span class="line">		ExFreePoolWithTag( NmiContext-&gt;stack_frames, STACK_FRAMES_POOL );</span><br><span class="line">		ExFreePoolWithTag( ProcAffinityPool, PROC_AFFINITY_POOL );</span><br><span class="line">		<span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Regiser our NMI callback and pass in a pointer to our NMI_CONTEXT structure as the Context argument */</span></span><br><span class="line">	PVOID registration_handle = KeRegisterNmiCallback( NmiCallback, NmiContext );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !registration_handle )</span><br><span class="line">	&#123;</span><br><span class="line">		ExFreePoolWithTag( NmiContext-&gt;thread_data_pool, THREAD_DATA_POOL );</span><br><span class="line">		ExFreePoolWithTag( NmiContext-&gt;stack_frames, STACK_FRAMES_POOL );</span><br><span class="line">		ExFreePoolWithTag( ProcAffinityPool, PROC_AFFINITY_POOL );</span><br><span class="line">		<span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* assign an arbitrary integer to be used as the delay period between NMIs */</span></span><br><span class="line">	LARGE_INTEGER delay = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	delay.QuadPart -= <span class="number">100</span> * <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Iterate through each core */</span></span><br><span class="line">	<span class="keyword">for</span> ( ULONG core = <span class="number">0</span>; core &lt; NmiContext-&gt;core_count; core++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Initialise the cores KAFFINITY_EX structure */</span></span><br><span class="line">		KeInitializeAffinityEx( proc_affinity_pool );</span><br><span class="line">		KeAddProcessorAffinityEx( proc_affinity_pool, core );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Send the NMI, passing in a pointer to the processor affinity pool */</span></span><br><span class="line">		HalSendNMI( proc_affinity_pool );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* Only a single NMI can be active at any given time, so arbitrarily</span></span><br><span class="line"><span class="comment">		* delay execution  to allow time for the NMI to be processed</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		KeDelayExecutionThread( KernelMode, FALSE, &amp;delay );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unregister our callback and free the processor affinity pool */</span></span><br><span class="line">	KeDeregisterNmiCallback( registration_handle );</span><br><span class="line">	ExFreePoolWithTag( proc_affinity_pool, PROC_AFFINITY_POOL );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here we use function <code>KeRegisterNmiCallback</code> to register our callback, passing in a pointer to our callback routine i.e the function we want executed when an NMI is triggered and a pointer to our context structure which we allocated on the stack in the caller and passed in as an argument. Before we get into how to fire an NMI, lets quickly go over what processor affinity is.</p>
<!-- TOC --><a name="what-is-processor-affinity"></a>
<h3 id="What-is-processor-affinity"><a href="#What-is-processor-affinity" class="headerlink" title="What is processor affinity?"></a>What is processor affinity?</h3><p>While most of what we did above was simply allocating memory to store things for analysis, you may be wondering what processor affinity is. Simply put, processor affinity is the binding of a thread to either a single core or a set of cpu cores, meaning the thread is only allowed to execute on those particular cores. The <code>KAFFINITY_EX</code> structure is simply a bitmask, with each bit specifiying a cpu core. Once we allocate a buffer for each core, we use <code>KeInitializeAffinityEx</code> to initialise the structure and then call <code>KeAddProcessorAffinityEx</code> by passing in the buffer and the core we want the thread binded to. Once the function returns, it means the thread is binded to whatever core number was passed in as an argument. So for example, if we pass in <code>core = 1</code>, the thread will only run on cpu core #1. </p>
<h3 id="Firing-an-NMI"><a href="#Firing-an-NMI" class="headerlink" title="Firing an NMI"></a>Firing an NMI</h3><p>Now to actually fire an NMI, you can either write a single line of inline asm using the <code>INT x</code> instruction using in the value of the non-maskable interrupt or you can simply use the hardware abstraction layers (<code>hal.dll</code>) exported function <code>HalSendNmi</code>which has the following signature:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">HalSendNMI</span><span class="params">(</span></span><br><span class="line"><span class="params">	PKAFFINITY_EX affinity</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>We can see it takes in a pointer to a <code>KAFFINITY_EX</code> strucuture, so we simply pass in the pointer to our processor affinity buffer. Now that we know how to fire an NMI, we need to use our callback to actually perform the stackwalk.</p>
<!-- TOC --><a name="how-to-stackwalk"></a>
<h2 id="What-is-Stack-Walking"><a href="#What-is-Stack-Walking" class="headerlink" title="What is Stack Walking"></a>What is Stack Walking</h2><p>Stack walking is the process of enumerating the return addresses stored on the stack. To give a quick overview, when a function is called (primarily through the <code>call</code> instruction), the instruction pointer, (<code>rip</code> register) which stores the address of the next instruction, is pushed onto the stack after the caller pushes the arguments onto the stack and sets up the new stack frame.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">|   Stack Frame <span class="number">1</span>   |</span><br><span class="line">|-------------------|</span><br><span class="line">|  Local Variables  |</span><br><span class="line">|-------------------|</span><br><span class="line">|  Return Address   | ------&gt; instruction pointer <span class="number">1</span></span><br><span class="line">+-------------------+</span><br><span class="line">|   Stack Frame  <span class="number">2</span>  |</span><br><span class="line">|-------------------|</span><br><span class="line">|  Local Variables  |</span><br><span class="line">|-------------------|</span><br><span class="line">|  Return Address   | ------&gt; instruction pointer <span class="number">2</span></span><br><span class="line">+-------------------+</span><br><span class="line">|   Stack Frame <span class="number">3</span>   |</span><br><span class="line">|-------------------|</span><br><span class="line">|  Local Variables  |</span><br><span class="line">|-------------------|</span><br><span class="line">|  Return Address   | ------&gt; instruction pointer <span class="number">3</span></span><br><span class="line">+-------------------+</span><br><span class="line">|   ...             |</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>What this means is that as a thread performs continuous function calls, the stack frame of that thread will contain every return address for the entire stack frame. We can then check if these return addresses (which are simply instruction pointers waiting to be popped back into the <code>rip</code> register) lie within a valid kernel module, since, after all, it is kernel execution.</p>
<h2 id="How-to-Stack-Walk-on-Windows"><a href="#How-to-Stack-Walk-on-Windows" class="headerlink" title="How to Stack Walk on Windows"></a>How to Stack Walk on Windows</h2><p>Windows offers us a few APIs that we can use to stackwalk, we are going to use <code>RtlCaptureStackBackTrace</code> which is an exported Windows function that walks the kernel stack and stores each return address in a caller allocated buffer. The signature is as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI USHORT <span class="title function_">RtlCaptureStackBackTrace</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]            ULONG  FramesToSkip,</span></span><br><span class="line"><span class="params">  [in]            ULONG  FramesToCapture,</span></span><br><span class="line"><span class="params">  [out]           PVOID  *BackTrace,</span></span><br><span class="line"><span class="params">  [out, optional] PULONG BackTraceHash</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>We can call this from our NMI callback and store the frames in the <code>stack_frames</code> buffer:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">NmiCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">	_In_ PVOID Context,</span></span><br><span class="line"><span class="params">	_In_ BOOLEAN Handled</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER( Handled );</span><br><span class="line"></span><br><span class="line">	NMI_CALLBACK_DATA thread_data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PNMI_CONTEXT nmi_context = ( PNMI_CONTEXT )Context;</span><br><span class="line">	ULONG proc_num = KeGetCurrentProcessorNumber();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We divide the stack frame pool size by the size of a pointer since each entry is 8 bytes. */</span></span><br><span class="line">	<span class="comment">/* We then store the frames in the stack_frames buffer at an offset determined by the processor number */</span></span><br><span class="line">	INT num_frames_captured = RtlCaptureStackBackTrace(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		STACK_FRAME_POOL_SIZE / <span class="keyword">sizeof</span>(UINT64),</span><br><span class="line">		( <span class="type">uintptr_t</span> )nmi_context-&gt;stack_frames + proc_num * STACK_FRAME_POOL_SIZE,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store the number of frames we captured and their offset from the base of the buffer */</span></span><br><span class="line">	thread_data.stack_frames_offset = proc_num * STACK_FRAME_POOL_SIZE;</span><br><span class="line">	thread_data.num_frames_captured = num_frames_captured;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy the stack allocated buffer to the buffer pointer to in the Context structure */</span></span><br><span class="line">	RtlCopyMemory(</span><br><span class="line">		( ( <span class="type">uintptr_t</span> )nmi_context-&gt;thread_data_pool ) + proc_num * <span class="keyword">sizeof</span>( thread_data ),</span><br><span class="line">		&amp;thread_data,</span><br><span class="line">		<span class="keyword">sizeof</span>( thread_data )</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Lets quickly walk through it. First, we are casting the Context argument to a type <code>PNMI_CONTEXT</code> which we defined before. Then, we call <code>RtlCaptureStackBackTrace</code> which walks the stack and stores each return address in an allocated buffer at an offset equal to the <code>processor number * size of frame pool</code>. This will allow us to easily index into the buffer to read each threads stack trace by using the processor number. Then, we copy this to the threads data bufffer and then return <code>TRUE</code> to signal that the NMI has been successfully processed.</p>
<!-- TOC --><a name="processing-the-stack-walk"></a>
<h2 id="Processing-the-Stack-Walk"><a href="#Processing-the-Stack-Walk" class="headerlink" title="Processing the Stack Walk"></a>Processing the Stack Walk</h2><p>Now that we have a stack trace from each interrupted thread, we need to process the information. For this I’ll define a function named <code>AnalyseNmiData</code> which does exactly as you’d expect. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">AnalyseNmiData</span><span class="params">(</span></span><br><span class="line"><span class="params">	_In_ PNMI_CONTEXT NmiContext,</span></span><br><span class="line"><span class="params">	_In_ PSYSTEM_MODULES SystemModules</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( !NmiContext || !SystemModules )</span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Iterate through each core on the system */</span></span><br><span class="line">	<span class="keyword">for</span> ( INT core = <span class="number">0</span>; core &lt; NmiContext-&gt;core_count; core++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Cast the thread_data pointer to a type PNMI_CALLBACK_DATA */</span></span><br><span class="line">		PNMI_CALLBACK_DATA thread_data = ( PNMI_CALLBACK_DATA )(</span><br><span class="line">			( <span class="type">uintptr_t</span> )NmiContext-&gt;thread_data_pool + core * <span class="keyword">sizeof</span>( NMI_CALLBACK_DATA ) );</span><br><span class="line"></span><br><span class="line">		DEBUG_LOG( <span class="string">&quot;cpu number: %i callback count: %i&quot;</span>, core, context-&gt;nmi_callbacks_run );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Iterate through each stack frame in the stack frame buffer of the current core, using the</span></span><br><span class="line"><span class="comment">		   num_frames_captured store in the thread_data structure. */</span></span><br><span class="line">		<span class="keyword">for</span> ( INT frame = <span class="number">0</span>; frame &lt; thread_data-&gt;num_frames_captured; frame++ )</span><br><span class="line">		&#123;</span><br><span class="line">			BOOLEAN flag;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Each frame is the size of a pointer, so cast each entry as a DWORD64* and then dereference to</span></span><br><span class="line"><span class="comment">			   get the actual stack trace value */</span></span><br><span class="line">			DWORD64 stack_frame = *( DWORD64* )( </span><br><span class="line">				( ( <span class="type">uintptr_t</span> )NmiContext-&gt;stack_frames + thread_data-&gt;stack_frames_offset + frame * <span class="keyword">sizeof</span>( PVOID ) ) );</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Check if the address lies within the bounds of a system module */</span></span><br><span class="line">			<span class="keyword">if</span> ( !NT_SUCCESS( IsInstructionPointerInInvalidRegion( stack_frame, SystemModules, &amp;flag ) ) )</span><br><span class="line">			&#123;</span><br><span class="line">				DEBUG_ERROR( <span class="string">&quot;errro checking RIP for current stack address&quot;</span> );</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* If the flag is equal to false, we have found invalid memory execution */</span></span><br><span class="line">			flag == TRUE</span><br><span class="line">				? DEBUG_LOG( <span class="string">&quot;RIP: %llx was xecuting within valid module&quot;</span>, stack_frame )</span><br><span class="line">				: DEBUG_ERROR( <span class="string">&quot;RIP %llx was executing in INVALID MEMORY&quot;</span>, stack_frame );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lets also define the <code>IsInstructionPointerInInvalidRegion</code> function:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">IsInstructionPointerInInvalidRegion</span><span class="params">(</span></span><br><span class="line"><span class="params">	_In_ UINT64 RIP,</span></span><br><span class="line"><span class="params">	_In_ PSYSTEM_MODULES SystemModules,</span></span><br><span class="line"><span class="params">	_Out_ PBOOLEAN Result</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( !RIP || !SystemModules || !Result )</span><br><span class="line">		<span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Note that this does not check for HAL or PatchGuard Execution */</span></span><br><span class="line">	<span class="keyword">for</span> ( INT i = <span class="number">0</span>; i &lt; SystemModules-&gt;module_count; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Cast each module to the correct type */</span></span><br><span class="line">		PRTL_MODULE_EXTENDED_INFO system_module = ( PRTL_MODULE_EXTENDED_INFO )(</span><br><span class="line">			( <span class="type">uintptr_t</span> )SystemModules-&gt;address + i * <span class="keyword">sizeof</span>( RTL_MODULE_EXTENDED_INFO ) );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Store the module base and the module end address in two values */</span></span><br><span class="line">		UINT64 base = ( UINT64 )system_module-&gt;ImageBase;</span><br><span class="line">		UINT64 end = base + system_module-&gt;ImageSize;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check if the address lies within the current module */</span></span><br><span class="line">		<span class="keyword">if</span> ( RIP &gt;= base &amp;&amp; RIP &lt;= end )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* If it does, set the flag to TRUE and return */</span></span><br><span class="line">			*Result = TRUE;</span><br><span class="line">			<span class="keyword">return</span> STATUS_SUCCESS;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we make it here the address was not within a valid module, set the flag and return */</span></span><br><span class="line">	*Result = FALSE;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function simply enumerates all modules in our <code>SystemModules</code> buffer, checking if the instruction pointer passed in as an argument lies within the region of atleast one of the system modules. Once it has found a module where the instruction pointer lies within, the function will return and set the <code>Result</code> flag to <code>true</code>. If no module contains this address, it will return <code>false</code>. Now, lets circle back to our <code>SetupAndRunNmiCallback</code> function to add in our latest functions:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">SetupAndRunNmiCallback</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	SYSTEM_MODULES system_modules = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NMI_CONTEXT nmi_context = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	nmi_context.core_count = KeQueryActiveProcessorCountEx( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !nmi_context.nmi_core_context )</span><br><span class="line">		<span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the system module information and store it in our buffer */</span></span><br><span class="line">	status = GetSystemModuleInformation( &amp;system_modules );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS( status ) )</span><br><span class="line">	&#123;</span><br><span class="line">		DEBUG_ERROR( <span class="string">&quot;Error retriving system module information&quot;</span> );</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Launch our non maskable interrupt, passing in our nmi context */</span></span><br><span class="line">	status = LaunchNonMaskableInterrupt( &amp;nmi_context );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS( status ) )</span><br><span class="line">	&#123;</span><br><span class="line">		DEBUG_ERROR( <span class="string">&quot;Error running NMI callbacks&quot;</span> );</span><br><span class="line">		ExFreePoolWithTag( system_modules.address, SYSTEM_MODULES_POOL );</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* analyse the nmi data for anomalies */</span></span><br><span class="line">	status = AnalyseNmiData( &amp;nmi_context, &amp;system_modules );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !NT_SUCCESS( status ) )</span><br><span class="line">		DEBUG_ERROR( <span class="string">&quot;Error analysing nmi data&quot;</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Free all memory */</span></span><br><span class="line">	<span class="keyword">if</span> (system_modules.address)</span><br><span class="line">		ExFreePoolWithTag( system_modules.address, SYSTEM_MODULES_POOL );</span><br><span class="line">	<span class="keyword">if</span> (nmi_context.stack_frames )</span><br><span class="line">		ExFreePoolWithTag( nmi_context.stack_frames, STACK_FRAMES_POOL );</span><br><span class="line">	<span class="keyword">if</span> (nmi_context.thread_data_pool )</span><br><span class="line">		ExFreePoolWithTag( nmi_context.thread_data_pool, THREAD_DATA_POOL );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here we simply put all the pieces together and that’s it! Now you simply need to call the <code>SetupAndRunNmiCallback</code> from your driver and you should see the following output in WinDbg:</p>
<p><img src="https://donnaskiez.github.io/blog/images/nmiimage.png" alt="WinDbgOutput"></p>
<p>Now, when this is run and an invalid thread with a stack return address that lies within a manually mapped module for example, it will be found you’ll be able to conduct further analysis on the memory region. I hope this was helpful, the full source code is available on my github <a target="_blank" rel="noopener" href="https://github.com/donnaskiez/nmi-callback-handler/tree/master">here</a>. Thanks for reading and have a lovely day c:.</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rationale"><span class="toc-number">1.</span> <span class="toc-text">Rationale</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flaws-with-Manual-Mapping"><span class="toc-number">2.</span> <span class="toc-text">Flaws with Manual Mapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-Kernel-Code-Execution-Bounds"><span class="toc-number">3.</span> <span class="toc-text">Windows Kernel Code Execution Bounds</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-Interrupts-and-Windows-IRQL"><span class="toc-number">4.</span> <span class="toc-text">CPU Interrupts and Windows IRQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-CPU-Interrupt"><span class="toc-number">4.1.</span> <span class="toc-text">What is a CPU Interrupt?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-IRQL"><span class="toc-number">4.2.</span> <span class="toc-text">Windows IRQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-Context"><span class="toc-number">5.</span> <span class="toc-text">Thread Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APCs-vs-DPCs"><span class="toc-number">6.</span> <span class="toc-text">APCs vs DPCs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-our-callback-routine"><span class="toc-number">7.</span> <span class="toc-text">Building our callback routine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-our-NMI-Callback-context"><span class="toc-number">7.1.</span> <span class="toc-text">Defining our NMI Callback context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-processor-affinity"><span class="toc-number">7.2.</span> <span class="toc-text">What is processor affinity?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Firing-an-NMI"><span class="toc-number">7.3.</span> <span class="toc-text">Firing an NMI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-Stack-Walking"><span class="toc-number">8.</span> <span class="toc-text">What is Stack Walking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-Stack-Walk-on-Windows"><span class="toc-number">9.</span> <span class="toc-text">How to Stack Walk on Windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Processing-the-Stack-Walk"><span class="toc-number">10.</span> <span class="toc-text">Processing the Stack Walk</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&text=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&is_video=false&description=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers&body=Check out this article: http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&title=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&name=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/09/18/How-Anti-Cheats-use-Non-Maskable-Interrupts-to-find-Invalid-Drivers/&t=How Anti-Cheats use Non-Maskable Interrupts to find Invalid Drivers"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    <a style="text-decoration:none;" target="_blank" rel="noopener" href="https://github.com/donnaskiez" class="fa-brands fa-github fa-2x"></a>
    <a style="text-decoration:none;" target="_blank" rel="noopener" href="https://twitter.com/donnaskiez" class="fa-brands fa-twitter fa-2x"></a>
    <a style="text-decoration:none;" target="_blank" rel="noopener" href="https://www.linkedin.com/in/lachlan-hodges-818210244/" class="fa-brands fa-linkedin fa-2x"></a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
